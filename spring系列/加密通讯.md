# 证书的构成和原理

最广泛的标准X.509的 v3版本规范定义了如下证书信息域：

- 版本号(Version Number）：规范的版本号，目前为版本3，值为0x2；
- 序列号（Serial Number）：由CA维护的为它所发的每个证书分配的一的列号，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能过20个字节；
- 签名算法（Signature Algorithm）：数字签名所采用的算法，如：sha256-with-RSA-Encryption、ccdsa-with-SHA2S6；
- 颁发者（Issuer）：发证书单位的标识信息，如 ” C=CN，ST=Beijing, L=Beijing, O=org.example.com CN=ca.org。example.com ”；
- 有效期(Validity): 证书的有效期很，包括起止时间。
- 主体(Subject) : 证书拥有者的标识信息（Distinguished Name），如：" C=CN，ST=Beijing, L=Beijing, CN=person.org.example.com”；
- 主体的公钥信息(SubJect Public Key Info）：所保护的公钥相关的信息：
  - 公钥算法 (Public Key Algorithm）公钥采用的算法；
  - 主体公钥（Subject Unique Identifier）：公钥的内容。
- 颁发者唯一号（Issuer Unique Identifier）：代表颁发者的唯一信息，仅2、3版本支持，可选；
- 主体唯一号（Subject Unique Identifier）：代表拥有证书实体的唯一信息，仅2，3版本支持，可选：
- 扩展（Extensions，可选）: 可选的一些扩展。中可能包括：
  - Subject Key Identifier：实体的秘钥标识符，区分实体的多对秘钥；
  - Basic Constraints：一指明是否属于CA;
  - Authority Key Identifier：证书颁发者的公钥标识符；
  - CRL Distribution Points: 撤销文件的颁发地址；
  - Key Usage：证书的用途或功能信息。

证书信任链, 最顶上的是“**根证书**”。除了根证书，其它证书都要依靠上一级的证书，来证明自己。根证书不可信，其它证书也不可信。

CA要对证书内容用自己的的私钥添加签名， 以防止别人对证书的内容进行篡改。



CA自己的数字证书(一般由CA自己生成)OS集成，并且信任。CA持自己发布的服务器证书对应的私钥，并对服务器证书加密，CA需要事先生成好CA自己的密钥对

Java虚拟机并不直接使用OS的证书认证机制，而是有另外的的security manager。jdk的security manager默认有一堆的根证书信任，保存在$JAVA_HOME\jre\lib\security\cacerts  （密码changeit）如果你的https站点证书是花钱申请的，被这些根证书所信任，那使用java来访问此https站点会非常方便。https证书是自己签名的，就需要将证书导入至JDK的信任证书中，否则访问时会报SSL错误。



# CA证书发布（CA私钥加密服务器的公钥）

1. 服务器生成和浏览器通讯密钥对

   服务器生成了一对公钥和私钥，并将私钥自行妥善保管。在这里，密钥对是由服务器自己生成的，也可以由认证机构代为生成。

2. 服务器CA注册自己可信任

   - 在这里服务器将自己的公钥发送给了CA
   - CA确认所收到的公钥是否为服务器本人所有，校验服务器
   - CA用自己的私钥对服务器的公钥加密签名并生成服务器证书。CA需要事先生成好CA自己的密钥对

   

3. 浏览器得到服务器的证书公钥    并获取CA机构本身的证书，它带有CA机构的公钥。

4. 浏览器用CA证书公钥  解密  服务器的证书 （由CA私钥加密的的服务器公钥）数字签名，得到服务器证书的指纹和指纹算法用这个公钥进行解密，然后使用这个指纹算法计算服务器证书的指纹，将这个计算的指纹与放在证书中的指纹对比，若一致，则表示服务器证书合法。

5. 浏览器用服务器证书的公钥加密消息并发送给服务器

6. 服务器用自己的私钥解密密文得到浏览器的消息

7. 浏览器和服务器在RSA掩护下协商对称加密算法和秘钥

# 完整通信过程

**step1**： “客户”向服务端发送一个通信请求

“客户”->“服务器”：你好

**step2**： “服务器”向客户发送自己的数字证书。证书中有一个公钥用来加密信息，私钥由“服务器”持有

“服务器”->“客户”：你好，我是服务器，这里是我的数字证书 

 

**step3**： “客户”收到“服务器”的证书后，它根据OS信任的CA证书验证这个服务器证书真实性。检查数字证书后，“客户”会发送一个随机的字符串给“服务器”用私钥去加密，服务器把加密的结果返回给“客户”，“客户”用公钥解密这个返回结果，如果解密结果与之前生成的随机字符串一致，那说明对方确实是私钥的持有者，或者说对方确实是“服务器”。会hash处理

“客户”->“服务器”：向我证明你就是服务器，这是一个随机字符串   //前面的例子中为了方便解释，用的是“你好”等内容，实际情况下一般是随机生成的一个字符串。

“服务器”->“客户”：{一个随机字符串hash}[私钥|RSA]

 

**step4**： 浏览器和服务器在RSA掩护下协商对称加密算法和秘钥，之后用对成加密通讯   “客户”会用公钥加密后发送给“服务器”，别人截获了也没用，因为只有“服务器”手中有可以解密的私钥。

“服务器”->“客户”：{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法]

“客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]

“服务器”->“客户”：{你好，你的余额是100元}[密钥|对称加密算法]

RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，**RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密**。